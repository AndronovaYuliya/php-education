# PHP для начинающих. Сессия
Всем хорошего дня, перед вами первая статья из серии для начинающих PHP разработчиков.
Она будет посвящена сессиям - это один из самых важных компонентов с которыми вам прийдется работать, 
не понимая принципа работы можно наворотить делов, так что я постараюсь рассказать о всех возможных нюансах.

Но для начала, чтобы понять, а зачем нам сессия, обратимся к истокам - к HTTP протоколу  

## HTTP Protocol
HTTP протокол - это HyperText Transfer Protocol — «протокол передачи гипертекста» - т.е. по сути - текстовый протокол.

> Изначально подразумевали, что по этому протоколу будет только HTML передаваться, отсель и название, а сейчас чего
> только не отправляют =^.^=

Давайте я вам приведу пример общения по HTTP протоколу, вот запрос:

```
GET / HTTP/1.1
Host: example.com
Accept: text/html

```

А вот ответ:
```
HTTP/1.1 200 OK
Content-Type: text/html; charset=utf-8

<html>
<head>...</head>
<body>...</body>
</html>
```

Это очень упрощенный пример, но и тут видно, что HTTP запрос и ответ состоят из трёх частей:

1. стартовая строка - для запроса содержит медот и путь запрашиваемой страницы, для ответа - версию протокола и код ответа 
2. заголовки - имеют формат ключ-значение разделенные двоеточием, каждый новый заголовок пишется с новой строки
3. тело сообщения - непосредственно HTML либо данные, тело отделяют от заголовков двумя переносами строки, может отсутствовать, как в приведенном запросе

Так, вроде с протоколом разобрались - он простой, ведёт свою историю аж с 1992-го года, так что идеальным его не назовешь, 
но какой есть - отправили запрос - получите ответ, и всё, сервер и клиент никоим образом более не связаны. Но подобный 
сценарий отнюдь не единственный возможный, у нас же может быть авторизация, сервер должен каким-то образом понимать, 
что вот этот запрос пришёл от определенного пользователя, т.е. клиент и сервер должны общаться в рамках некой сессии.
И да, для этого придумали следующий механизм:

1. при авторизации пользователя, сервер генерирует и запоминает уникальный ключ - идентификатор сессии, и сообщает его браузеру
2. браузер сохраняет этот ключ, и при каждом последующем запросе, его отправляет

Для хранения ключа браузер использует cookie - простые текстовые файлы на вашем компьютере, по файлу для каждого домена,
при этом браузер накладывает ограничение на количество записей и размер хранимых данных (для большинства браузеров это
4096 байт, см. [RFC 2109](http://www.ietf.org/rfc/rfc2109.txt) от 1997-го года) 

> Т.е. если украсть cookie из вашего браузера, то можно будет зайти на вашу страничку в фейсбук от вашего имени. 
> Но не пугайтесь, так сделать нельзя, по крайней мере с фейсбуком, и дальше я вас найчу как можно защититься от данного
> вида атаки

Давайте теперь посмотрим как изменятся наши запрос-ответ, будь там авторизация:

```
POST /login/ HTTP/1.1
Host: example.com
Accept: text/html

login=Username&password=Userpass
```

Запрос у нас изменился на POST, и в теле запроса у нас передаются логин и пароль (если использовать метод GET, то строка 
запроса может оказаться сохраненной на каких нибудь промежуточных прокси серверах, что очень плохо для логина и пароля).


```
HTTP/1.1 200 OK
Content-Type: text/html; charset=utf-8
Set-Cookie: KEY=VerySecretUniqueKey

<html>
<head>...</head>
<body>...</body>
</html>
```

Ответ сервер будет содержать заголовок `Set-Cookie: KEY=VerySecretUniqueKey`, что заставит браузер сохранить эти данные
в файлы, и при следующем обращении к серверу - они будут отправлены:


```
GET / HTTP/1.1
Host: example.com
Accept: text/html
Cookie: KEY=VerySecretUniqueKey

```

> Как можно заметить, заголовки отправляемые браузером (Request Headers) и сервером (Response Headers) отличаются,
> хотя есть и общие и для запросов и для ответов (General Headers)

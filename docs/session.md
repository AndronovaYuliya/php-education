# PHP для начинающих. Сессия
Всем хорошего дня, перед вами первая статья из серии для начинающих PHP разработчиков.
Это будет необычная серия статей, тут не будет `echo "Hello World"`, тут будет hardcode из жизни PHP разработчиков.

Начну с сессий - это один из самых важных компонентов с которыми вам придется работать, 
не понимая принципа работы можно наворотить делов, так что я постараюсь рассказать о всех возможных нюансах.

Но для начала, чтобы понять, а зачем нам сессия, обратимся к истокам - к HTTP протоколу.

## HTTP Protocol
HTTP протокол - это HyperText Transfer Protocol — «протокол передачи гипертекста» - т.е. по сути - текстовый протокол.

> Изначально подразумевали, что по этому протоколу будет только HTML передаваться, отсель и название, а сейчас чего
> только не отправляют（•_ㅅ_•）=^.^= 

Чтобы не ходить вокруг да около, давайте я вам приведу пример общения по HTTP протоколу, вот запрос, 
каким его отправляет ваш браузер, когда вы запрашиваете страницу `http://example.com`:

```
GET / HTTP/1.1
Host: example.com
Accept: text/html

```

А вот пример ответа:
```
HTTP/1.1 200 OK
Content-Type: text/html; charset=utf-8

<html>
<head>...</head>
<body>...</body>
</html>
```

Это очень упрощенные примеры, но и тут можно увидеть из чего состоят HTTP запрос и ответ:

1. стартовая строка - для запроса содержит медот и путь запрашиваемой страницы, для ответа - версию протокола и код ответа 
2. заголовки - имеют формат ключ-значение разделенные двоеточием, каждый новый заголовок пишется с новой строки
3. тело сообщения - непосредственно HTML либо данные, тело отделяют от заголовков двумя переносами строки, может отсутствовать, как в приведенном запросе

Так, вроде с протоколом разобрались - он простой, ведёт свою историю аж с 1992-го года, так что идеальным его не назовешь, 
но какой есть - отправили запрос - получите ответ, и всё, сервер и клиент никоим образом более не связаны. Но подобный 
сценарий отнюдь не единственный возможный, у нас же может быть авторизация, сервер должен каким-то образом понимать, 
что вот этот запрос пришёл от определенного пользователя, т.е. клиент и сервер должны общаться в рамках некой сессии.
И да, для этого придумали следующий механизм:

1. при авторизации пользователя, сервер генерирует и запоминает уникальный ключ - идентификатор сессии, и сообщает его браузеру
2. браузер сохраняет этот ключ, и при каждом последующем запросе, его отправляет

Для реализации этого механизма и были созданы cookie - простые текстовые файлы на вашем компьютере, по файлу для каждого домена 
(хотя некоторые браузеры более продвинутые, и используют для хранения SQLite базу данных),
при этом браузер накладывает ограничение на количество записей и размер хранимых данных (для большинства браузеров это
4096 байт, см. [RFC 2109](http://www.ietf.org/rfc/rfc2109.txt) от 1997-го года) 

> Т.е. если украсть cookie из вашего браузера, то можно будет зайти на вашу страничку в фейсбук от вашего имени. 
Но не пугайтесь, так сделать нельзя, по крайней мере с фейсбуком, и дальше я вас найчу как можно защититься от данного
вида атаки на ваших пользователей.

Давайте теперь посмотрим как изменятся наши запрос-ответ, будь там авторизация:

```
POST /login/ HTTP/1.1
Host: example.com
Accept: text/html

login=Username&password=Userpass
```

Метод у нас изменился на POST, и в теле запроса у нас передаются логин и пароль (если использовать метод GET, то строка 
запроса может оказаться сохраненной на каких нибудь промежуточных прокси серверах, что очень плохо для логина и пароля).


```
HTTP/1.1 200 OK
Content-Type: text/html; charset=utf-8
Set-Cookie: KEY=VerySecretUniqueKey

<html>
<head>...</head>
<body>...</body>
</html>
```

Ответ сервер будет содержать заголовок `Set-Cookie: KEY=VerySecretUniqueKey`, что заставит браузер сохранить эти данные
в файлы cookie, и при следующем обращении к серверу - они будут отправлены:


```
GET / HTTP/1.1
Host: example.com
Accept: text/html
Cookie: KEY=VerySecretUniqueKey

```

> Как можно заметить, заголовки отправляемые браузером (Request Headers) и сервером (Response Headers) отличаются,
хотя есть и общие и для запросов и для ответов (General Headers)

Так, ну вроде с сессиями и HTTP разобрались, теперь можно вернутся к PHP и его особенностям.

## PHP и сессия

> Я надеюсь, у вас уже установлен PHP на компьютере, т.к. дальше я буду приводить примеры, и их надо будет запускать

Язык PHP создавался под стать протоколу HTTP - т.е. основная его задача - это дать ответ на HTTP запрос и "умереть"
освободив память и ресурсы. Следовательно, и механизм сессий работает в PHP не в автоматическом режиме, а в ручном,
и нужно знать что вызвать, да и в каком порядке.

> Вот вам статейка на тему [PHP is meant to die](http://software-gunslinger.tumblr.com/post/47131406821/php-is-meant-to-die),
или вот она же [на русском языке](https://habrahabr.ru/post/179399/), но лучше отложите её в закладки на потом.

Перво-наперво необходимо "стартовать" сессию - для этого воспользуемся функцией [session_start()](http://php.net/function.session-start),
создайте файл `session.start.php` со следующим содержимым:

```php
<?php
    session_start();
```

Запустите встроенный в PHP [web-server](http://php.net/features.commandline.webserver) в папке с вашим скриптом:

```
php -S 127.0.0.1:8080
```

и зайдите в браузере на страницу http://127.0.0.1:8080/session.start.php, вы должны увидеть лишь пустую страницу, но не спешите
закрывать, откройте Developer Tools (или [что там у вас](https://en.wikipedia.org/wiki/Web_development_tools#Web_developer_tools_support)),
и посмотрите на заголовки которые нам прислал сервер:

[[session.start.cookie.png]]

Там будет много чего, интересует нас только вот эта строчка в ответе сервера (почистите куки, если нет такой строчки, и обновите страницу):

```
Set-Cookie: PHPSESSID=dap83arr6r3b56e0q7t5i0qf91; path=/
```

Увидев сие, браузер сохранит у себя куку с именем `PHPSESSID`:

[[session.start.cookie.png]]

> `PHPSESSID` - имя сессии по умолчанию, регулируется сие из конфига php.ini директивой [session.name](http://php.net/session.configuration#ini.session.name),
при необходимости имя можно изменить в самом конфигурационном файле или с помощью функции [session_name()](http://php.net/function.session-name)

И теперь - обновляем страничку, и видим, что браузер отправляет эту куку на сервер, можете попробовать пару раз обновить
страницу, результат будет идентичным:

[[session.start.request.png]]

Итого, что мы имеем - теория совпала с практикой, и это просто отлично. 

Теперь перейдём к следующему шагу - сохраним в сессию произвольное значение, для этого в PHP используется супер-глобальная
переменная `$_SESSION`, сохранять будем текущее время - для этого вызовем функцию [date()](http://php.net/function.date):
 
```php
<?php
    session_start();
    $_SESSION['time'] = date("H:i:s");
    echo $_SESSION['time'];
```

Обновляем страничку и видим время сервера, обновляем ещё раз - и время обновилось. Давайте теперь сделаем так, чтобы 
установленное время не изменялось при каждом обновлении страницы:

```php
<?php
    session_start();
    if (!isset($_SESSION['time'])) {
        $_SESSION['time'] = date("H:i:s");
    }
    echo $_SESSION['time'];
```

Обновляем - есть, время не меняется. Но при этом мы помним, PHP умирает, значит данную сессию он где-то хранит, и мы  
найдём это место...

## Всё тайное становится явным

По умолчанию, PHP хранит сессию в файлах - за это отвечает директива [session.save_handler](http://php.net/session.configuration#ini.session.save-handler),
путь по которому сохраняются файлы ищите в директиве [session.save_path](http://php.net/session.configuration#ini.session.save-path),
либо воспользуйтесь функцией [session_save_path()](http://php.net/function.session-save-path) для получения необходимого пути.

> В вашей конфигурации путь к файлам может быть не указан, тогда файлы сессии будут хранится во временных файлах вашей
системы - вызовите функцию [sys_get_temp_dir](http://php.net/sys_get_temp_dir) и узнайте где это потаённое место.

Так, идём по данному пути и находим ваш файл сессии (у меня это файл `sess_dap83arr6r3b56e0q7t5i0qf91`), 
откроем его в текстовом редакторе:

```
time|s:8:"16:19:51";
```

Как видим - вот оно наше время, вот в таком хитром формате хранится наша сессия, но мы можем внести правки, 
поменять время, или можем просто вписать любую строку, почему бы и нет:

```
time|s:13:"\m/ (@.@) \m/";
```

> Для преобразования этой строки в массив нужно воспользоваться функцией [session_decode()](http://php.net/function.session-decode),
для обратного преобразования - [session_encode()](http://php.net/function.session-encode) - это зовется сериализацией,
вот только в PHP для сессий - она своя - особенная, хотя можно использовать и стандартную [PHP сериализацию](http://php.net/function.serialize) - 
пропишите в конфигурационной директиве [session.serialize_handler](http://php.net/session.configuration#ini.session.serialize-handler) 
значение `php_serialize` и будет вам счастье, и `$_SESSION` можно будет использовать без ограничений - в качестве индекса 
теперь вы сможете использовать цифры и специальные символы `|` и `!` в имени (за все 10 лет работы, ни разу не надо было :)

Так, что мы ещё не пробовали? Правильно - украсть куки, давайте запустим другой браузер и добавим в него туже самую куку.
Я вам для этого простенький javascript написал, скопируйте его в консоль браузера и запустите, только не забудьте идентификатор
сессии поменять на ваш:

```js
javascript:(function(){document.cookie='PHPSESSID=dap83arr6r3b56e0q7t5i0qf91;path=/;';window.location.reload();})()
```

Вот теперь у вас оба браузера смотрят на одну и туже сессию. Я выше упоминал, что расскажу о способах защиты, рассмотрим
самый простой способ - привяжем сессию к браузеру, точнее к тому, как браузер представляется серверу - будем запоминать 
`User-Agent` и проверять его каждый раз:

```php
<?php
    session_start();
    
    if (!isset($_SESSION['time'])) {
        $_SESSION['ua'] = $_SERVER['HTTP_USER_AGENT'];
        $_SESSION['time'] = date("H:i:s");
    }
    
    if ($_SESSION['ua'] != $_SERVER['HTTP_USER_AGENT']) {
        die('Wrong browser');
    }
    
    echo $_SESSION['time'];

```

Это подделать сложнее, но всё ещё возможно, добавьте сюда ещё сохранение и проверку `$_SERVER['REMOTE_ADDR']`
и `$_SERVER['HTTP_X_FORWARDED_FOR']`, и это уже более-менее будет походить на защиту от злоумышленников посягающих
на куки.

> **Задание**
Добавьте в код проверку на IP пользователя, если проверка не прошла - удалите скомпроментированную сессию.

## А есть ли жизнь без "печенек"?

PHP может работать с сессией даже если cookie в браузере отключены, но тогда все URL на сайте будут содержать параметр
с идентификатором вашей сессии, и да - это ещё настроить надо, но оно вам надо? Мне не приходилось это использовать, но
если очень хочется - я просто скажу где копать:

* [session.use_cookies](http://php.net/session.configuration#ini.session.use-cookies)
* [session.use_only_cookies](http://php.net/session.configuration#ini.session.use-only-cookies)



